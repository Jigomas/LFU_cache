//Сравнение реализаций

тестер -

// Вставь сюда содержимое ideal_cache.hpp
// Вставь сюда содержимое ideal_cache.cpp без int main()
 

static void IdealCacheTest(benchmark::State& state) {
    // Тестовые данные
    std::string test_input = "20 270 7 15 3 12 19 8 4 16 11 1 9 18 6 14 2 10 5 17 13 20 15 7 12 3 8 19 16 4 1 11 18 9 6 14 10 2 17 5 13 20 7 15 3 12 19 8 4 16 11 1 9 18 6 14 2 10 5 17 13 20 15 7 12 3 8 19 16 4 1 11 18 9 6 14 10 2 17 5 13 20 7 15 3 12 19 8 4 16 11 1 9 18 6 14 2 10 5 17 13 20 15 7 12 3 8 19 16 4 1 11 18 9 6 14 10 2 17 5 13 20 7 15 3 12 19 8 4 16 11 1 9 18 6 14 2 10 5 17 13 20 15 7 12 3 8 19 16 4 1 11 18 9 6 14 10 2 17 5 13 20 7 15 3 12 19 8 4 16 11 1 9 18 6 14 2 10 5 17 13 20 15 7 12 3 8 19 16 4 1 11 18 9 6 14 10 2 17 5 13 20 7 15 3 12 19 8 4 16 11 1 9 18 6 14 2 10 5 17 13 20 15 7 12 3 8 19 16 4 1 11 18 9 6 14 10 2 17 5 13 20 7 15 3 12 19 8 4 16 11 1 9 18 6 14 2 10 5 17 13 20 15 7 12 3 8 19 16 4 1 11 18 9 6 14 10 2 17 5 13 20";
    std::istringstream input_stream(test_input);
    
    // Сохраняем оригинальные cin буферы
    auto orig_cin_buf = std::cin.rdbuf();
    
    for (auto _ : state) {
        // Перенаправляем cin на наш тестовый ввод
        std::cin.rdbuf(input_stream.rdbuf());
        
        // Запускаем тест
        size_t hit_count = RunIdeal();
        
        // Восстанавливаем cin
        std::cin.rdbuf(orig_cin_buf);
        
        // Сбрасываем поток для следующей итерации
        input_stream.clear();
        input_stream.seekg(0);
        
        // Предотвращаем оптимизацию
        benchmark::DoNotOptimize(hit_count);
    }
    
    // Восстанавливаем оригинальный cin
    std::cin.rdbuf(orig_cin_buf);
}

BENCHMARK(IdealCacheTest);









//////////////////////////////////////////////////////////////////
вариант 1 НАЧАЛЬНЫЕ ДАННЫЕ cpu_time = 226 809



template<typename KeyT, typename ValueT>
void IdealCache<KeyT, ValueT>::UpdateNextUses() {
	for (auto& [key, entry] : data_) {
		auto seq_it = access_sequence_.find(key);
		if (seq_it != access_sequence_.end()) {
			while (!seq_it->second.empty() && seq_it->second.front() <= current_access_index_) {
				seq_it->second.pop();
			}
			
			if (!seq_it->second.empty()) {
				entry.next_use = seq_it->second.front();
			} else {
				entry.next_use = std::numeric_limits<size_t>::max();
			}
		} else {
			entry.next_use = std::numeric_limits<size_t>::max();
		}
	}
}



//////////////////////////////////////////////////////////////////
вариант 2 cpu_time = 227 596



template<typename KeyT, typename ValueT>
void IdealCache<KeyT, ValueT>::UpdateNextUses() {
    for (auto& [key, entry] : data_) {
        auto seq_it = access_sequence_.find(key);
        if (seq_it == access_sequence_.end()) {
            entry.next_use = std::numeric_limits<size_t>::max();
            continue;
        }
        
        auto& queue = seq_it->second;
        if (!queue.empty() && queue.front() <= current_access_index_) {
            queue.pop();
        }
        
        entry.next_use = queue.empty() ? std::numeric_limits<size_t>::max() : queue.front();
    }
}



//////////////////////////////////////////////////////////////////
вариант 3 cpu_time = 221 407



template<typename KeyT, typename ValueT>
void IdealCache<KeyT, ValueT>::UpdateNextUses() {
    for (auto& [key, entry] : data_) {
        auto seq_it = access_sequence_.find(key);
        if (seq_it == access_sequence_.end()) {
            entry.next_use = std::numeric_limits<size_t>::max();
            continue;
        }        
        auto& queue = seq_it->second;
        while (!queue.empty() && queue.front() <= current_access_index_) {
            queue.pop();
        }
        
        entry.next_use = queue.empty() ? std::numeric_limits<size_t>::max() : queue.front();
    }
}



//////////////////////////////////////////////////////////////////
вариант 4 cpu_time = 237 431



template<typename KeyT, typename ValueT>
void IdealCache<KeyT, ValueT>::UpdateNextUses() {
    for (auto& [key, entry] : data_) {
        auto seq_it = access_sequence_.find(key);
        if (seq_it == access_sequence_.end()) {
            entry.next_use = std::numeric_limits<size_t>::max();
            continue;
        }
        
        auto& queue = seq_it->second;
        if (queue.empty()) {
            entry.next_use = std::numeric_limits<size_t>::max();
            continue;
        }
        
        while (queue.front() <= current_access_index_) {
            queue.pop();
            if (queue.empty()) break; 
        }
        
        entry.next_use = queue.empty() ? std::numeric_limits<size_t>::max() : queue.front();
    }
}







выбрали вариант 3
*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
вариант 1 cpu_time = 221 407



template<typename KeyT, typename ValueT>
IdealCache<KeyT, ValueT>::IdealCache(size_t capacity)
	: capacity_(capacity), size_(0), current_access_index_(0) {}




//////////////////////////////////////////////////////////////////
вариант 2 cpu_time = 215 398



template<typename KeyT, typename ValueT>
IdealCache<KeyT, ValueT>::IdealCache(size_t capacity)
    : capacity_(capacity), size_(0), current_access_index_(0) {
    data_.reserve(capacity_);                    
    access_sequence_.reserve(capacity_ * 3);     
}




*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
вариант 1 cpu_time = 220 900


template<typename KeyT, typename ValueT>
void IdealCache<KeyT, ValueT>::Remove() {
	if (data_.empty()) return;

	auto target = data_.begin();
	size_t furthest_use = target->second.next_use;

	for (auto it = data_.begin(); it != data_.end(); ++it) {
		if (it->second.next_use > furthest_use) {
			furthest_use = it->second.next_use;
			target = it;
		}
	}

	data_.erase(target);
	--size_;
}



//////////////////////////////////////////////////////////////////
вариант 2 cpu_time = 215 398



template<typename KeyT, typename ValueT>
void IdealCache<KeyT, ValueT>::Remove() {
    if (data_.empty()) return;

    auto target = std::max_element(data_.begin(), data_.end(),
        [](const auto& a, const auto& b) {
            return a.second.next_use < b.second.next_use;
        });
    
    data_.erase(target);
    --size_;
}